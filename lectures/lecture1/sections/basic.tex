\section{Основы}

%------------------------------------------------

\begin{frame}
    \center \Huge Основы
\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Целые числа}

    существуют

    полезные
\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Целые числа. Представление числа}
    Числа представляются в двоичной системе счисления

    \begin{itemize}
        \item 0 = 00000000
        \item 8 = 00001000
        \item 53 = 00110101
        \item 255 = 01111111
    \end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Целые числа. Побитовые оперции}

    \begin{tabular}{cc}
        \begin{minipage}{.33\linewidth}
            \begin{table}[h!]
                Побитовое не \sim \\
                \begin{tabular}{|c|c|}
                    \hline
                    a & \sim a \\ [0.5ex]
                    \hline\hline
                    0    & 1    \\
                    1    & 0    \\
                    \hline
                \end{tabular}
            \end{table}
        \end{minipage}

        \begin{minipage}{.25\linewidth}
            \begin{table}[h!]
                Побитовое и \& \\
                \begin{tabular}{|c|c|c|}
                    \hline
                    a & b & a\&b \\[0.5ex]
                    \hline\hline
                    0 & 0 & 0  \\
                    0 & 1 & 0  \\
                    1 & 0 & 0  \\
                    1 & 1 & 1  \\
                    \hline
                \end{tabular}
            \end{table}
        \end{minipage}

        \begin{minipage}{.33\linewidth}
            \begin{table}[h!]
                Побитовое и \& \\
                \begin{tabular}{|c|c|c|}
                    \hline
                    a & b & a\&b \\[0.5ex]
                    \hline\hline
                    0 & 0 & 0  \\
                    0 & 1 & 0  \\
                    1 & 0 & 0  \\
                    1 & 1 & 1  \\
                    \hline
                \end{tabular}
            \end{table}
        \end{minipage}
    \end{tabular}
\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Целые числа. Побитовые оперции}

    \begin{tabular}{cc}
        \begin{minipage}{.5\linewidth}
            \begin{table}[h!]
                Побитовое или | \\
                \begin{tabular}{|c|c|c|}
                    \hline
                    a & b & a\&b \\[0.5ex]
                    \hline\hline
                    0 & 0 & 0  \\
                    0 & 1 & 1  \\
                    1 & 0 & 1  \\
                    1 & 1 & 1  \\
                    \hline
                \end{tabular}
            \end{table}
        \end{minipage}

        \begin{minipage}{.4\linewidth}
            \begin{table}[h!]
                Побитовый xor \^ \\
                \begin{tabular}{|c|c|c|}
                    \hline
                    a & b & a\&b \\[0.5ex]
                    \hline\hline
                    0 & 0 & 0  \\
                    0 & 1 & 1  \\
                    1 & 0 & 1  \\
                    1 & 1 & 0  \\
                    \hline
                \end{tabular}
            \end{table}
        \end{minipage}
    \end{tabular}
\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Целые числа. Побитовые оперции}

    \begin{center}
        Побитовый сдвиг вправо >> и побитовый сдвиг влево <<: \\
        00010101 << 1 = 00101010 \\
        21 << 1 = 42 = 21 \times $2^1$ \\
        0000011010100111 >> 1 = 0000001101010011 \\
        1703 >> 1 = 851 = 1703 / $2^1$ \\
    \end{center}

\end{frame}

%------------------------------------------------
\begin{frame}
    \frametitle{Целочисленные типы данных в языке с++}

    \begin{center}
        \small
        \begin{tabular}{|c|c|c|}
            \hline
            Тип & Размер & Значения \\
            \hline
            short int & 16 & -32,768 --- 32,767\\
            \hline
            unsigned short int & 16 & 0 --- 65,535\\
            \hline
            int & 32 & -2,147,483,648 --- 2,147,483,647\\
            \hline
            unsigned int & 32 & 0 -- 4,294,967,295\\
            \hline
            long int & 32 & -2,147,483,648 --- 2,147,483,647\\
            \hline
            unsigned long int & 32 & 0 -- 4,294,967,295\\
            \hline
            long long int & 64 & -9,223,372,036,854,775,808 --- 9,223,372,036,854,775,807\\
            \hline
            unsigned long long int & 64 & 0 --- 18,446,744,073,709,551,615\\
            \hline
        \end{tabular}
    \end{center}

    \quad Модификаторы: short, long, signed, unsigned\\
    \quad При подключении заколовочного файла <cstdint> можно писать int[8/16/32/64/128]\_t и uint[8/16/32/64/128]\_t
\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Отрицательные целые числа}
    \quad Очевидная запись: от всех чисел отнимать константу. Эта константа будет минимальных числом.

    \quad Пример: пусть константа 52, а в памяти записано в двоичном виде число 42. Значит фактически число в этой переменной 42-52=-10   

    \quad Решение рабочее, но медленное и неудобное.

    \quad Как же хранится число на самом деле? 

    \quad Первый(самый старший) бит числа отвечает за знак. Тогда чтобы из положительного получить отрицателное нужно сделать операцию $-a = \sim a - 1$ но чем же это лучше?
\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Переполнения целых чисел}

    \quad Что будет если в восьмибитном знаковом числе сложить 89 и 100? Максимальное число это 127, что меньше этой суммы. Ответом будет -67.

    \quad Вернёмся к представлению числа чтобы понять почему так происходит.

    \quad $87 = 01010111$\\
    \quad $100 = 01100100$\\
    \quad $100 + 87 = 187 = 10111011$, что при первом бите ответственном за знак является $10111011 = -(01000100 - 00000001) = -67$. Не выглядит удобным. В чём же польза?

\end{frame}

%------------------------------------------------

\begin{frame}
    \frametitle{Переполнения целых чисел}

    \quad Рассмотрим сумму чисел разных знаков

    \quad $-87 = 10101001$\\
    \quad $100 = 01100100$\\
    \quad $10101001 + 01100100 = 00001101 = 13$. Сумма сработала без каких либо дополнительных операций. Подобным свойством обладают также разность, умножение и деление. Фактически реализация разности и деления вовсе необязательна. На этом факте строиться Дерево Фенвика из примера асимптотического анализа алгоритма.

\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
    \frametitle{Ввод и вывод}

    \begin{cpp}
        #include <iostream>
        using namespace std;
        int main(){
            std::ios_base::sync_with_stdio(0);
            cin.tie(0);
            cout.tie(0);

            string s;
            cin >> s;
            cout << "Hello, mister " << s << "!";

            cin.flush();
            cout << "\n" << std::endl;
            
            return 0;
        }
    \end{cpp}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
    \frametitle{Ввод и вывод}
    Ускорение ввода и вывода
    \begin{cpp}
            std::ios_base::sync_with_stdio(0);
            cin.tie(0);
            cout.tie(0);
    \end{cpp}

    Очистка буфера
    \begin{cpp}
            cout.flush();
    \end{cpp}

    НЕ ОДНО И ТО ЖЕ!!!
    \begin{cpp}
            cout << "\n";
            cout << endl;
    \end{cpp}
    
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
    \frametitle{Строки}
    
    \quad Под капотом строки на самом деле это не более чем массив символов с одной особенностью. В конце находится терминальный символ с значением 0. Такую записать можно представить так:
    \begin{cpp}
        char a[4] = {'1', '2', '3', 0};
        char b[4] = {'1', '2', '3', '\0'};
    \end{cpp}
\end{frame}

%------------------------------------------------
