\section{Бинпоиск по ответу}

\begin{frame}
    Нередко встречаются задачи сводимые к подобным:
    \begin{enumerate}
        \item Ваня хочет получить не меньше x рублей\dots найдите минимальный x, что его удовлетворяет
        \item Даня хочет получить не больше x пересдач\dots найдите максимальный x, что его удовлетворяет
    \end{enumerate}
    Проблема в том, что обычно условия сложнее
\end{frame}

\begin{frame}
    Давайте представим первую как функцию f(x)
    \begin{enumerate}
        \item f(x) = 1, если Ваня доволен(x удовлетворяет условиям задачи)
        \item f(x) = 0, если Ваня недоволен(x не удовлетворяет условиям задачи)
    \end{enumerate}
    Тогда массив [f(1), f(2)\dots f(много)] выглядит как [0, 0, \dots, 1, 1, 1, \dots] --- функция монотонна!
\end{frame}

\begin{frame}
    \frametitle{Пример задачи}
    На прямой расположены n стоил, в которые необходимо расставить коров так, чтобы минимальное расcтояние между коровами было как можно больше. У каждого стойла есть координата, на которой оно расположено. Нужно найти минимальное расстояние между коровами при самой оптимальной расстановке.
\end{frame}

\begin{frame}
    \frametitle{По какому параметру делать бинпоиск?}
\end{frame}

\begin{frame}
    \frametitle{По какому параметру делать бинпоиск?}
\end{frame}

\begin{frame}
    \frametitle{По какому параметру делать бинпоиск?}
    Поскольку он у нас один свободный, очевидно что по минимальному расстоянию между коровами
\end{frame}

\begin{frame}
    \frametitle{Какую функцию задать?}
\end{frame}

\begin{frame}
    \frametitle{Какую функцию задать?}
    f(x) = 1, если есть расстановка, что нет коров ближе чем на x, 0 иначе
\end{frame}

\begin{frame}
    \frametitle{Какую функцию задать?}
    f(x) = 1, если есть расстановка, что нет коров ближе чем на x, 0 иначе\\
    Монотонная функция, подходит. Теперь ищем наибольший x, что f(x) = 1
\end{frame}

\begin{frame}[fragile]
    \frametitle{Решение}
    \begin{cpp}
int l = 0, r = 1e9;
while (l + 1 < r) {
    int m = (l + r) / 2;
    int remain = k - 1;
    int prev = st[0];
    for (int i = 1; i < n; i++) {
        if (st[i] - prev >= m) {
            prev = st[i];
            remain--;
        }
    }
    if (remain > 0) {
        r = m;
    } else l = m;
}
return l;
    \end{cpp}
\end{frame}

